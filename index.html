<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>EOS Follow Time Planner</title>
  <style>
    :root{
      --bg:#050608;
      --bg2:#14161b;
      --line:#292c33;
      --muted:#9ea3b3;
      --text:#f5f7ff;
      --accent:#4da3ff;
      --accentSoft: rgba(77,163,255,.22);
      --warn:#f1c40f;
      --danger:#ff5c5c;
      --input:#101218;
      --inputLine:#2b303a;
    }

    *{box-sizing:border-box}
    body{
      margin:0;
      padding:24px;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      background: radial-gradient(circle at top, #192033 0, var(--bg) 55%);
      color:var(--text);
      min-height:100vh;
      display:flex;
      justify-content:center;
      align-items:stretch;
    }

    .app{width:100%; max-width:1100px; margin:auto}
    .header{
      display:flex;
      justify-content:space-between;
      align-items:flex-end;
      gap:12px;
      flex-wrap:wrap;
      margin-bottom:12px;
    }
    h1{
      margin:0;
      font-size:1.55rem;
      letter-spacing:.04em;
      text-transform:uppercase;
    }
    .sub{
      margin:4px 0 0;
      color:var(--muted);
      font-size:.9rem;
    }

    .btnRow{display:flex; gap:8px; flex-wrap:wrap}
    button{
      border-radius:999px;
      border:1px solid transparent;
      padding:7px 14px;
      font-size:.85rem;
      cursor:pointer;
      background:#232632;
      color:var(--text);
      transition: transform .05s ease, background .15s ease, border-color .15s ease;
      white-space:nowrap;
      display:inline-flex;
      align-items:center;
      gap:6px;
    }
    button:hover{background:#2c313d; transform:translateY(-1px)}
    button:active{transform:translateY(0)}
    button.primary{
      background:var(--accent);
      border-color:var(--accent);
      color:#020308;
      font-weight:700;
      box-shadow:0 0 18px var(--accentSoft);
    }
    button.primary:hover{background:#6bb1ff}
    button.outline{background:transparent; border-color:var(--line)}
    button.danger{
      background: rgba(255,92,92,.10);
      border-color: rgba(255,92,92,.55);
      color:#ffb4b4;
    }

    .panel{
      background: linear-gradient(145deg, var(--bg2), #0e1016);
      border:1px solid var(--line);
      border-radius:18px;
      padding:16px 18px 18px;
      box-shadow:
        0 24px 60px rgba(0,0,0,.7),
        0 0 0 1px rgba(255,255,255,.02);
    }

    .panelTop{
      display:flex;
      justify-content:space-between;
      align-items:flex-start;
      gap:10px;
      flex-wrap:wrap;
      margin-bottom:10px;
    }
    .panelTitle{
      color:var(--muted);
      text-transform:uppercase;
      letter-spacing:.08em;
      font-size:.9rem;
    }
    .hint{
      color:var(--muted);
      font-size:.82rem;
      text-align:right;
      line-height:1.25;
      max-width:520px;
    }
    .hint code{
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      background: rgba(255,255,255,.04);
      padding:2px 5px;
      border-radius:6px;
    }

    table{width:100%; border-collapse:collapse; margin-top:6px}
    thead{background:#181b23}
    th,td{padding:7px 6px; text-align:left}
    th{
      font-weight:600;
      color:var(--muted);
      text-transform:uppercase;
      letter-spacing:.08em;
      font-size:.72rem;
      border-bottom:1px solid #232633;
    }
    tbody tr:nth-child(even){background: rgba(255,255,255,.01)}
    tbody tr:hover{background: rgba(77,163,255,.06)}

    .cCue{width:70px}
    .cTime{width:190px}
    .cFollow{width:240px}
    .cDel{width:60px; text-align:center}

    input[type="text"]{
      width:100%;
      padding:6px 7px;
      border-radius:8px;
      border:1px solid var(--inputLine);
      background:var(--input);
      color:var(--text);
      font-size:.92rem;
      outline:none;
      transition: border-color .12s ease, box-shadow .12s ease, background .12s ease;
    }
    input[type="text"]:focus{
      border-color:var(--accent);
      box-shadow:0 0 0 1px var(--accentSoft);
      background:#141722;
    }
    input.invalid{
      border-color:var(--danger)!important;
      box-shadow:0 0 0 1px rgba(255,92,92,.25);
    }

    .mono{
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      font-size:.86rem;
      color:#cfd3e6;
      white-space:nowrap;
    }
    .mono.dim{color:#555a6b; font-style:italic}
    .mono.err{color:var(--danger); font-style:normal}

    .miniBtn{
      padding:4px 10px;
      border-radius:999px;
      background:transparent;
      border-color: rgba(255,92,92,.6);
      color:#ffaaaa;
      font-size:.8rem;
    }
    .miniBtn:hover{background: rgba(255,92,92,.08)}

    .footer{
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:10px;
      flex-wrap:wrap;
      margin-top:14px;
    }
    .tag{
      font-size:.8rem;
      padding:3px 8px;
      border-radius:999px;
      background: rgba(255,255,255,.03);
      border:1px solid rgba(255,255,255,.05);
      color:var(--muted);
    }

    .msg{
      margin-top:8px;
      min-height:18px;
      font-size:.82rem;
      color:var(--muted);
    }
    .msg .warn{color:var(--warn)}
    .msg .ok{color:#9ad19a}

    .export{
      margin-top:14px;
      padding:10px 10px;
      border-radius:12px;
      background: rgba(0,0,0,.35);
      border:1px dashed #2c3140;
    }
    .exportTitle{
      color:var(--muted);
      text-transform:uppercase;
      letter-spacing:.08em;
      font-size:.72rem;
      margin-bottom:6px;
    }
    .exportText{
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      font-size:.82rem;
      white-space:pre-wrap;
      max-height:120px;
      overflow:auto;
      color:#d4d8ea;
    }

    @media (max-width: 720px){
      body{padding:12px}
      .panel{padding:12px}
      th:nth-child(4), td:nth-child(4){display:none} /* hide notes on tiny screens */
      .cFollow{width:190px}
    }
  </style>
</head>
<body>
  <div class="app">
    <div class="header">
      <div>
        <h1>EOS Follow Time Planner</h1>
        <p class="sub">Enter your song cue points — get follow times between each cue.</p>
      </div>

      <div class="btnRow">
        <button class="outline" id="btnRecalc">Recalculate</button>
        <button class="danger" id="btnReset">Reset</button>
      </div>
    </div>

    <div class="panel">
      <div class="panelTop">
        <div class="panelTitle">Cue List</div>
        <div class="hint">
          Formats:
          <code>min.sec</code>,
          <code>min:sec</code>,
          <code>hr:min:sec</code>.
          <br>
          Calculates when you click out of a time field (or press <code>Recalculate</code>).
        </div>
      </div>

      <table>
        <thead>
          <tr>
            <th class="cCue">Cue</th>
            <th class="cTime">Song Time</th>
            <th class="cFollow">Follow From Previous</th>
            <th>Notes</th>
            <th class="cDel">Del</th>
          </tr>
        </thead>
        <tbody id="tbody"></tbody>
      </table>

      <div class="footer">
        <div class="btnRow">
          <button class="primary" id="btnAdd">+ Add Cue</button>
          <span class="tag">Output: seconds &amp; min:sec</span>
          <span class="tag" id="tagSave">Autosave: on</span>
        </div>
      </div>

      <div class="msg" id="msg"></div>

      <div class="export">
        <div class="exportTitle">Quick copy for EOS</div>
        <div class="exportText" id="export"></div>
      </div>
    </div>
  </div>

  <script>
    // --------- State ---------
    const STORAGE_KEY = "eos_follow_time_planner_v2";

    /** @type {{ timeRaw: string, note: string }[]} */
    let cues = [];

    // --------- DOM ---------
    const elTbody = document.getElementById("tbody");
    const elMsg = document.getElementById("msg");
    const elExport = document.getElementById("export");
    const elTagSave = document.getElementById("tagSave");

    document.getElementById("btnAdd").addEventListener("click", () => {
      cues.push({ timeRaw: "", note: "" });
      save();
      render();
      // focus new row time input
      const last = elTbody.querySelector("tr:last-child input.time");
      if (last) last.focus();
    });

    document.getElementById("btnRecalc").addEventListener("click", () => recalcAndUpdateUI(true));
    document.getElementById("btnReset").addEventListener("click", reset);

    // Event delegation for inputs and delete
    elTbody.addEventListener("click", (e) => {
      const btn = e.target.closest("button[data-action='del']");
      if (!btn) return;

      const idx = Number(btn.dataset.index);
      if (!Number.isFinite(idx)) return;

      cues.splice(idx, 1);
      save();
      render();
      recalcAndUpdateUI(false);
    });

    // Update state on input, but DO NOT recalc until blur (click out)
    elTbody.addEventListener("input", (e) => {
      const time = e.target.closest("input.time");
      const note = e.target.closest("input.note");
      if (!time && !note) return;

      const row = e.target.closest("tr[data-index]");
      if (!row) return;
      const idx = Number(row.dataset.index);
      if (!Number.isFinite(idx) || !cues[idx]) return;

      if (time) cues[idx].timeRaw = time.value;
      if (note) cues[idx].note = note.value;

      save();
    });

    // Recalc ONLY when leaving a time field
    elTbody.addEventListener("blur", (e) => {
      const time = e.target.closest("input.time");
      if (!time) return;
      recalcAndUpdateUI(false);
    }, true);

    // --------- Parsing / Formatting ---------

    // Dot format is NOT decimal. It is a separator.
    // Supports:
    // - min.sec     (12.57 -> 12:57)
    // - hr.min.sec  (1.02.30 -> 1:02:30)
    // - min:sec
    // - hr:min:sec
    // Auto-carry:
    // - 12.70 -> 13:10
    // - 0:75  -> 1:15
    // - 1.99  -> 2:39
    function parseSongTime(raw) {
      if (!raw) return NaN;
      const t = raw.trim();
      if (!t) return NaN;

      // Dot formats: digits.digits(.digits)?
      if (/^\d+\.\d+(\.\d+)?$/.test(t)) {
        const parts = t.split(".").map(s => s.trim());
        const nums = parts.map(s => Number(s));
        if (nums.some(n => Number.isNaN(n) || n < 0)) return NaN;

        // min.sec
        if (parts.length === 2) {
          let min = nums[0];

          // If seconds chunk is 1 digit (12.7), interpret as 07 seconds
          const sChunk = parts[1];
          let sec = (sChunk.length === 1) ? Number("0" + sChunk) : nums[1];
          if (!Number.isFinite(sec) || sec < 0) return NaN;

          // carry
          min += Math.floor(sec / 60);
          sec = sec % 60;

          return (min * 60) + sec;
        }

        // hr.min.sec
        if (parts.length === 3) {
          let hr = nums[0];

          const mChunk = parts[1];
          const sChunk = parts[2];

          let min = (mChunk.length === 1) ? Number("0" + mChunk) : nums[1];
          let sec = (sChunk.length === 1) ? Number("0" + sChunk) : nums[2];
          if ([min, sec].some(n => !Number.isFinite(n) || n < 0)) return NaN;

          // carry
          min += Math.floor(sec / 60);
          sec = sec % 60;

          hr += Math.floor(min / 60);
          min = min % 60;

          return (hr * 3600) + (min * 60) + sec;
        }

        return NaN;
      }

      // Colon formats (allow overflow; auto-carry happens naturally)
      if (!/^\d+:\d+(:\d+)?$/.test(t)) return NaN;
      const parts = t.split(":").map(s => s.trim());
      if (parts.length < 2 || parts.length > 3) return NaN;
      const nums = parts.map(s => Number(s));
      if (nums.some(n => Number.isNaN(n) || n < 0)) return NaN;

      if (parts.length === 2) return (nums[0] * 60) + nums[1];
      return (nums[0] * 3600) + (nums[1] * 60) + nums[2];
    }

    function fmtMinSec(totalSeconds) {
      const sec = Math.round(totalSeconds);
      const h = Math.floor(sec / 3600);
      const m = Math.floor((sec % 3600) / 60);
      const s = sec % 60;
      const pad2 = (n) => String(n).padStart(2, "0");
      if (h > 0) return `${h}:${pad2(m)}:${pad2(s)}`;
      return `${m}:${pad2(s)}`;
    }

    // --------- Render / Recalc ---------

    function render() {
      elTbody.innerHTML = cues.map((c, i) => rowHTML(i, c)).join("");
      elTagSave.textContent = "Autosave: on";
    }

    function rowHTML(i, c) {
      return `
        <tr data-index="${i}">
          <td class="cCue"><span class="mono">${i + 1}</span></td>
          <td class="cTime">
            <input class="time" type="text" inputmode="decimal"
                   placeholder="min.sec or min:sec"
                   value="${escapeAttr(c.timeRaw)}" />
          </td>
          <td class="cFollow">
            <span class="mono dim" data-follow="${i}">—</span>
          </td>
          <td>
            <input class="note" type="text" placeholder="Optional notes"
                   value="${escapeAttr(c.note)}" />
          </td>
          <td class="cDel">
            <button class="miniBtn" type="button" data-action="del" data-index="${i}">X</button>
          </td>
        </tr>
      `;
    }

    function recalcAndUpdateUI(userRequested) {
      const rows = [...elTbody.querySelectorAll("tr[data-index]")];
      const times = [];
      const invalids = [];

      // parse times (do not rewrite the input)
      for (const row of rows) {
        const idx = Number(row.dataset.index);
        const input = row.querySelector("input.time");
        const raw = (input?.value ?? "").trim();
        const sec = raw ? parseSongTime(raw) : NaN;

        times[idx] = sec;

        // visual invalid
        if (raw && Number.isNaN(sec)) {
          input.classList.add("invalid");
          invalids.push(idx + 1);
        } else {
          input.classList.remove("invalid");
        }
      }

      // follows + export
      const exportLines = [];
      const warnings = [];

      for (let i = 0; i < cues.length; i++) {
        const followEl = elTbody.querySelector(`[data-follow="${i}"]`);
        const cur = times[i];

        if (i === 0) {
          if (followEl) followEl.textContent = "—";
          if (!Number.isNaN(cur)) exportLines.push(`Cue 1: at ${fmtMinSec(cur)} (song)`);
          else exportLines.push(`Cue 1: —`);
          continue;
        }

        const prev = times[i - 1];

        if (!Number.isNaN(cur) && !Number.isNaN(prev)) {
          const diff = cur - prev;
          if (diff < 0) {
            if (followEl) {
              followEl.textContent = "Negative (check order)";
              followEl.className = "mono err";
            }
            warnings.push(`Cue ${i + 1} is earlier than Cue ${i}.`);
            exportLines.push(`Cue ${i + 1}: song ${fmtMinSec(cur)} (order?)`);
          } else {
            const d = Math.round(diff);
            if (followEl) {
              followEl.textContent = `${d}s (${fmtMinSec(d)})`;
              followEl.className = "mono";
            }
            exportLines.push(`Cue ${i + 1}: Follow ${d}s  (from ${fmtMinSec(prev)} → ${fmtMinSec(cur)})`);
          }
        } else {
          if (followEl) {
            followEl.textContent = "—";
            followEl.className = "mono dim";
          }
          exportLines.push(`Cue ${i + 1}: —`);
        }
      }

      elExport.textContent = exportLines.join("\n");

      // messages
      if (invalids.length) {
        elMsg.innerHTML = `<span class="warn">Invalid time in cue(s): ${invalids.join(", ")}.</span>`;
      } else if (warnings.length) {
        elMsg.innerHTML = `<span class="warn">${warnings.join(" ")}</span>`;
      } else {
        elMsg.innerHTML = userRequested
          ? `<span class="ok">Recalculated.</span>`
          : ``;
      }
    }

    // --------- Save / Load / Reset ---------

    function save() {
      try {
        localStorage.setItem(STORAGE_KEY, JSON.stringify(cues));
        elTagSave.textContent = "Autosave: saved";
      } catch {
        elTagSave.textContent = "Autosave: off";
      }
    }

    function load() {
      try {
        const raw = localStorage.getItem(STORAGE_KEY);
        if (!raw) return false;
        const data = JSON.parse(raw);
        if (!Array.isArray(data)) return false;

        cues = data.map(x => ({
          timeRaw: typeof x?.timeRaw === "string" ? x.timeRaw : "",
          note: typeof x?.note === "string" ? x.note : ""
        }));

        if (!cues.length) return false;
        return true;
      } catch {
        return false;
      }
    }

    function reset() {
      cues = [
        { timeRaw: "0.00", note: "Start of song" },
        { timeRaw: "", note: "" },
        { timeRaw: "", note: "" },
      ];
      save();
      render();
      recalcAndUpdateUI(false);
    }

    // --------- Helpers ---------
    function escapeAttr(s) {
      return String(s ?? "")
        .replaceAll("&", "&amp;")
        .replaceAll('"', "&quot;")
        .replaceAll("<", "&lt;")
        .replaceAll(">", "&gt;");
    }

    // --------- Init ---------
    if (!load()) reset();
    render();
    recalcAndUpdateUI(false);
  </script>
</body>
</html>
